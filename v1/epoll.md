- ET模式与LT模式
  - ET模式是边缘触发,主要在状态发生变换的时候出现相应的改变,即,从不可读转变成为可读状态的时候
  - 可能存在的问题:
    1. TCP是无边界的，是字节流，需要应用层自己判断包边界，一次不一定能收几包，也不一定是完整的包,可能发生粘包问题(本质上算是一个国内计算机领域的伪科学的感觉),尤其是在ET模式下面(没有读取完,MSS都没规划好吧...(4字节那个))(在redis内部是分两段读取的,首先读取包的长度以及包的内容,这个是固定字长的,再读取对应的数据)
    2. 在ET模式下,加入没有读取完毕,直接就会发送到对应的epoll_wait,继续等待一个轮回了...(ET只在对方可读可写时触发)
      - 再一个轮回是指:只有下一次本fd被事件触发的时候,才能再次调用事件处理函数,本质上未对一个包进行完整的读取会导致事件处理函数调用的不可靠.(一个函数处理了上一个包以及下一个包的数据)  
    4. 在epoll发送大文件的条件下,实际上是会发生分段的,由于TCP实际上并不care边界,socket的缓冲区是当前主要问题存在的地方,(256K什么的),达到缓冲区对应的长度之后,是会报一个EAGIN错误的,因此,在这个时候,应该要重新的房一下(说白了就是在一个for循环里面)
    5. UDP是按照报文接受的,所以...在处理UDP的时候,我们必须一个保温一个报文的接受,而且每一个都接收完毕
  - ET模式在connection建立的时候,会发出一个EPOLLOUT可写事件(针对客户端),对应Listen会产生一个EPOLLIN事件(针对服务器),在对应回调函数中可以使用accept函数接受对应的连接(在继续使用epoll的时候也必须进行事件的注册与回调函数的分发)
  - ET模式会出现阻塞的情况,在大文件读写的EAGIN的errno(可能是超过了当前网络缓存大小,写的太快了),当可以写的时候(阻塞状态木有了),就有了EPOLLOUT
  - EPOLLIN不想写,没啥赛艇的地方~~
  - 总体来说，ET处理EPOLLOUT方便高效些，LT不容易遗漏事件、不易产生bug如果server的响应通常较小，不会触发EPOLLOUT，那么适合使用LT，例如redis等。而nginx作为高性能的通用服务器，网络流量可以跑满达到1G，这种情况下很容易触发EPOLLOUT，则使用ET。[知乎](https://www.zhihu.com/question/20502870/answer/89738959)
- 使用ET模式一般是需要使用fcntl将对应的文件描述符修改为非阻塞的,主要基于组要的考虑:在阻塞模式的情况下,只有在读写完全之后才会接受到对端的信号.当接收方没有读取完所有的数据时,ET模式的使用会导致
  - 文件描述符重入epoll,但是由于在阻塞模式下工作,因此不会发出信号,对写方来说,永久的等待,epoll也处于永久的等待状态(由于ET模式),接受方也出于永久的等待(由于epool无法接受到值).就是永久阻塞了.产生了starving.


redis非异步读写的模式为何不考虑阻塞?
- 在代码中我们明显没有发现redis使用异步读写模式(aio),在大部分时候也没有使用对应的aio控制块及其系统函数
- 当前主要使用的是非阻塞(0_NONBLOCK)而非对应的异步(AIO)读写,非阻塞读写在读写时本质线程还是处于等待系统调用完成的状态
- 本质是由于:redis的发送的数据量普遍不大,在考虑当前主要的内核栈网络缓存在128KB大小的情况下,普遍不用考虑跑满的可能性,errno=EAGIN的出现频次少,使用异步读写容易出问题(出错怎么办?谁来做error handler?)

关于connect的模式的问题
- 因为epoll本身没有明确提出当异步connect成功之后会返回什么样的信号，那就测试，试验呗。 
1. 当本地还没调用connect函数，却将套接字送交epoll检测，epoll会产生一次 EPOLLOUT | EPOLLHUP， 也就是产生一个值为0x14的events. 
2. 当本地connect事件发生了，但建立连接失败，则epoll会产生一次 EPOLLIN | EPOLLERR | EPOLLHUP， 也就是一个值为0x19的events. 
3. 当connect函数也调用了，而且连接也顺利建立了，则epoll会产生一次 EPOLLOUT， 值为0x4，即表明套接字已经可写。 
因而，要判断连接建立，只需要判断该套接字有可写属性且仅有可写属性即可。 
4. PS：本例中使用的epoll采用ET模式

在之前的叙述中,主要描述了非阻塞读的主要实现方法,现在问题来了,非阻塞的写应该如何操作了,由于epool主要是用在一些比较特殊的地方,它主要是基于读写**事件**进行调用的.对于写这个操作来说,主要的实现也需要evpoll的支持,**本质上是操作系统之上的,使用非阻塞IO的redis直接构建的异步事件模型(比操作系统的更方便做错误处理啥的,read和write的时候本质上还是阻塞的)**:
- 使用一个缓存,将需要写入的信息放入缓存中,使的具体的写与抽象的写进行了分离
- 当前是由networking主要实现对应的读写支持的,函数`sendReplyToClient`是一个ev的回调函数,主要处理异步写入的相关问题,在写入的过程中,会循环调用写函数,在一定时候会产生EAGIN错误(当前的写入内容超过了对应的接收门限),于是停下来就可以了(由于有事件驱动的加持,当前的函数还是会在下一次EPOLLIN事件的时候被调用,就继续写呗
- 一旦写入完成,就可以直接将对应的事件取消了.算是完成了读写的任务吧(而且一点也没有被阻塞住)