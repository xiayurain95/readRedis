- ET模式与LT模式
  - ET模式是边缘触发,主要在状态发生变换的时候出现相应的改变,即,从不可读转变成为可读状态的时候
  - 可能存在的问题:
    1. TCP是无边界的，是字节流，需要应用层自己判断包边界，一次不一定能收几包，也不一定是完整的包,可能发生粘包问题,尤其是在ET模式下面(没有读取完,MSS都没规划好吧...(4字节那个))
    2. 在ET模式下,加入没有读取完毕,直接就会发送到对应的epoll_wait,继续等待一个轮回了...
    3. 在epoll发送大文件的条件下,实际上是会发生分段的,由于TCP实际上并不care边界,socket的缓冲区是当前主要问题存在的地方,(256K什么的),达到缓冲区对应的长度之后,是会报一个EAGIN错误的,因此,在这个时候,应该要重新的房一下(说白了就是在一个for循环里面)
    4. UDP是按照报文接受的,所以...在处理UDP的时候,我们必须一个保温一个报文的接受,而且每一个都接收完毕
  - ET模式在connection建立的时候,会发出一个EPOLLOUT可写事件
  - ET模式会出现阻塞的情况,在大文件读写的EAGIN的errno,当可以写的时候(阻塞状态木有了),就有了EPOLLOUT
  - EPOLLIN不想写,没啥赛艇的地方~~
  - 总体来说，ET处理EPOLLOUT方便高效些，LT不容易遗漏事件、不易产生bug如果server的响应通常较小，不会触发EPOLLOUT，那么适合使用LT，例如redis等。而nginx作为高性能的通用服务器，网络流量可以跑满达到1G，这种情况下很容易触发EPOLLOUT，则使用ET。[知乎](https://www.zhihu.com/question/20502870/answer/89738959)
- 使用ET模式一般是需要使用fcntl将对应的文件描述符修改为非阻塞的,主要基于组要的考虑:在阻塞模式的情况下,只有在读写完全之后才会接受到对端的信号.当接收方没有读取完所有的数据时,ET模式的使用会导致
  - 文件描述符重入epoll,但是由于在阻塞模式下工作,因此不会发出信号,对写方来说,永久的等待,epoll也处于永久的等待状态(由于ET模式),接受方也出于永久的等待(由于epool无法接受到值).就是永久阻塞了.产生了starving.

关于connect的模式的问题
- 因为epoll本身没有明确提出当异步connect成功之后会返回什么样的信号，那就测试，试验呗。 
1. 当本地还没调用connect函数，却将套接字送交epoll检测，epoll会产生一次 EPOLLOUT | EPOLLHUP， 也就是产生一个值为0x14的events. 
2. 当本地connect事件发生了，但建立连接失败，则epoll会产生一次 EPOLLIN | EPOLLERR | EPOLLHUP， 也就是一个值为0x19的events. 
3. 当connect函数也调用了，而且连接也顺利建立了，则epoll会产生一次 EPOLLOUT， 值为0x4，即表明套接字已经可写。 
因而，要判断连接建立，只需要判断该套接字有可写属性且仅有可写属性即可。 
4. PS：本例中使用的epoll采用ET模式

在之前的叙述中,主要描述了非阻塞读的主要实现方法,现在问题来了,非阻塞的写应该如何操作了,由于epool主要是用在一些比较特殊的地方,它主要是基于读写**事件**进行调用的.对于写这个操作来说,主要的实现也需要evpoll的支持:
- 使用一个缓存,将需要写入的信息放入缓存中,使的具体的写与抽象的写进行了分离
- 当前是由networking主要实现对应的读写支持的,函数`sendReplyToClient`是一个ev的回调函数,主要处理异步写入的相关问题,在写入的过程中,会循环调用写函数,在一定时候会产生EAGIN错误(当前的写入内容超过了对应的接收门限),于是停下来就可以了(由于有事件驱动的加持,当前的函数还是会在下一次EPOLLIN事件的时候被调用,就继续写呗
- 一旦写入完成,就可以直接将对应的事件取消了.算是完成了读写的任务吧(而且一点也没有被阻塞住)